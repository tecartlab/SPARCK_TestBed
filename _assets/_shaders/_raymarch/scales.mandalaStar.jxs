<jittershader name="ray.template.jxs">
	<description>SPARCK - ShaderTemplate - (c) 2017 by maybites</description>

	<param name="sprk_worldMatrix" type="mat4" state="WORLD_MATRIX" />
	<param name="sprk_rotMatrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="sprk_viewPos" type="vec3" default="0. 0. 0." description="test"/>
	<param name="sprk_worldRefPos" type="vec3" default="0. 0. 0." description="test"/>
	<param name="sprk_globalTime" type="float" default="0." />
	<param name="sprk_scale" type="float" default="1." />

	<param name="tex0" type="int" default="0" />
	<param name="tex1" type="int" default="1" />

    <!-- COMMENT: add here your own parameters...

    copy and modify the following lines outsite of this comment section:

	<param name="myVeryOwnFloat" type="float" default="1." description="Use_underscore_for_spaces_to_seperate_'words'"/>
	<param name="myVeryOwnVec3" type="vec3" default="0. 0. 0." description="text with spaces will only show up as 'text'"/>

    you can use parameters of the following types:

        TYPES       GUI     QUE

        -float      y       y
        -vec2       y       y
        -vec3       y       y
        -vec4       y       y
        -mat3       -       y
        -mat4       -       y

        DON'T USE int: it is reserved for textures!!

    GUI: The RayMarching Node will scan the parameters and tries to make them accessible through the userinterface
    QUE: These parameters can be sent to this shader via OSC or QueScript.

    ...Dont forget to bind it the shader: END OF COMMENT-->

	<language name="glsl" version="1.2">
		<bind param="sprk_worldMatrix" program="vp" />
		<bind param="sprk_rotMatrix" program="fp" />
		<bind param="sprk_scale" program="fp" />
		<bind param="sprk_viewPos" program="fp" />
		<bind param="sprk_worldRefPos" program="fp" />
		<bind param="sprk_globalTime" program="fp" />

		<bind param="tex0" program="fp" />
		<bind param="tex1" program="fp" />

        <!-- COMMENT: bind your own parameters here to the vertex shader (vp) and/or fragment shader (fp)

        copy and modify the following lines outsite of this comment section:

        <bind param="myVeryOwnFloat" program="fp" />
        <bind param="myVeryOwnVec3" program="fp" />

        ...until here.-->

		<program name="vp" type="vertex">
<![CDATA[

// >>>>> ================================
// >>>>> DO NOT CHANGE ANYTHING FROM HERE
// >>>>> ================================

#version 120

uniform mat4 sprk_worldMatrix;
uniform mat4 sprk_rotMatrix;

varying vec3 sprk_normal;	// surface normal
varying vec3 sprk_localPos;	// vertex local position
varying vec3 sprk_worldPos;	// vertex world position

varying vec2 sprk_texcoord0;
varying vec2 sprk_texcoord1;
varying vec2 sprk_texdim0;
varying vec2 sprk_texdim1;

void main(void)
{
	// perform standard transform on vertex (general approach)
	gl_Position = ftransform();

	gl_TexCoord[0]  = gl_TextureMatrix[0] * gl_MultiTexCoord0;

	sprk_normal = normalize(mat3(sprk_worldMatrix) * gl_Normal);
	sprk_localPos = vec3(sprk_rotMatrix * gl_Vertex);
	sprk_worldPos = vec3(sprk_worldMatrix * gl_Vertex);

	// transform texcoords
    sprk_texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
    sprk_texcoord1 = vec2(gl_TextureMatrix[1] * gl_MultiTexCoord1);
    // extract the x and y scalars from the texture matrix to determine dimensions
    sprk_texdim0 = vec2 (abs(gl_TextureMatrix[0][0][0]),abs(gl_TextureMatrix[0][1][1]));
    sprk_texdim1 = vec2 (abs(gl_TextureMatrix[1][0][0]),abs(gl_TextureMatrix[1][1][1]));
}

]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[

uniform vec3 sprk_viewPos; 			// point of view position
uniform vec3 sprk_worldRefPos;      // reference position of this virtual world
uniform mat4 sprk_rotMatrix; 		// rotation matrix
uniform float sprk_scale;			// viewline scale
uniform float sprk_globalTime; 		// time

varying vec3 sprk_normal;			// surface normal
varying vec3 sprk_worldPos;			// vertex world position
varying vec3 sprk_localPos;			// vertex local position

// samplers
uniform sampler2DRect tex0;			// texture reference for texture 0
uniform sampler2DRect tex1;			// texture reference for texture 1

// texcoords
varying vec2 sprk_texcoord0;		// texture coordinate for texture 0
varying vec2 sprk_texdim0;			// texture dimension for texture 0
varying vec2 sprk_texcoord1;		// texture coordinate for texture 1
varying vec2 sprk_texdim1;			// texture dimension for texture 0

// ================================= <<<<<<
// ...................... UNTIL HERE <<<<<<
// ================================= <<<<<<

// From here onwards will be your custom code...

// *************************************************************************
//
// Created by: kosmonaut
//		https://www.shadertoy.com/view/Wt33W8
//
// *************************************************************************

// Add here your own parameters

uniform float myVeryOwnFloat;
uniform vec3 myVeryOwnVec3;

// If your old shader code came from shadertoy.com and used mouse interaction,
// these values will usually lead to good results
// since we dont need them anymore they can be static.

vec2 iMouse = vec2(0.5, 0.5);
vec2 iResolution = vec2(1, 1);
float iGlobalTime = sprk_globalTime;

// >>>>>>>>>>>>>>>>>>>>>>

const float PI = 3.14159265359;

const float alpha = PI * 2./3.;

const float verticalWidth = 1.5;
const float verticalWaveHeight = 0.2;
const float verticalWaveWidth = 1.5;

const float aa_width = 2.8;
const float borderWidth = .8;
const float bezelWidth = 0.5;

mat2 rot = mat2(cos(alpha), -sin(alpha), sin(alpha), cos(alpha));

const float timeScale = .2;

const float shearFactor = 1.1;

#define SHOWBEZEL

////////////////////////////
// COLORS
const vec3 gold = vec3(252. / 255., 186. / 255., 3. / 255.);
const vec3 green = vec3(111. / 255., 232. / 255., 84. / 255.);
const vec3 violet = vec3(77. / 255., 4. / 255., 212. / 255.);
const vec4 backgroundColor = vec4(82./255.);
const vec4 backgroundRed = vec4(240./255., 108./255., 0., 1.);
const vec4 backgroundLines2 = vec4(79./255., 36./255., 0., 1.);

const vec3 blue = vec3(21. / 255., 170. / 255., 230. / 255.);

mat2 getRotMatrix(float rad)
{
    float c = cos(rad);
    float s = sin(rad);
    return mat2(c, -s, s, c);
}

vec4 drawLine(vec2 coord, const float waveHeight, const float waveWidth, const float width)
{
    float verticalOffset = waveHeight * sin(alpha);
    vec2 origin = vec2(verticalOffset * .5, 0.);

    coord -= origin;
 	float verticalPosition = sin(coord.y /waveHeight *2.* PI)*waveWidth;

    float diff = abs(verticalPosition + verticalOffset/2. - mod(coord.x, verticalOffset) );
    vec4 color = vec4( smoothstep(diff, diff+aa_width, width), vec3(0.));

    // Bezel
    color += vec4(vec3(0.),smoothstep(diff+aa_width, diff+bezelWidth, width+ borderWidth));

    //shadow
    color += vec4(0., smoothstep(width, diff+aa_width, width + borderWidth), 0., 0.);

    return vec4(color);
}
// <<<<<<<<<<<<<<<<<<<<<<


// the main function needs to look like this:

void main() {
    // It should start with the following code block

    // =================  DO NOT CHANGE THIS CODE  =============================
	vec4 sprk_vl_raw = vec4(sprk_worldPos - sprk_viewPos - sprk_worldRefPos, 1);
	vec3 sprk_vl_dir = (sprk_rotMatrix * sprk_vl_raw).xyz;
	vec3 sprk_ray    = normalize(sprk_vl_dir) * sprk_scale;
    // =================  DO NOT CHANGE THIS CODE  =============================

    // usefull variables that are controlled by the RayMarching Node are:

    //  sprk_ray        (vec3) -> it is THE RAY
    //  sprk_viewPos;   (vec3) -> the world postion of your eye
    //  sprk_localPos   (vec3) -> the place where the ray hits the canvas. (local coordinate system)
    //  sprk_worldPos   (vec3) -> the place where the ray hits the canvas. (global coordinate system)
    //  sprk_rotMatrix  (mat4) -> rotates the ray around itself
    //  sprk_scale      (float)-> scales the ray
    //  sprk_globalTime (float)-> the global time in seconds

	// example code for gathering texture color:

    //vec3 sprk_texColor0   = texture2DRect(tex0, sprk_texcoord0).rgb;
    //vec3 sprk_texColor1   = texture2DRect(tex1, sprk_texcoord1).rgb;

    // >>>>>>>>>>>>>>>>>>>>>>

		vec2 fragCoord = sprk_texcoord0.xy;
		float iTime = sprk_globalTime;

		vec4 lines;

    float beta = PI/4. + sin(iTime*.25*timeScale) * sin(iTime*.3*timeScale + 1.);

    mat2 rotation = getRotMatrix(beta);

    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = vec2((fragCoord.x - 0.5) / 0.5, fragCoord.y - .5);

    // translation for eventual rotation around something around the middle of the screen
    vec2 rotationOrigin = iResolution.xy * mix(.1, .2, sin(iTime*.5*timeScale));
    fragCoord -= rotationOrigin;

    // Some zooming in/out
    fragCoord *= 1.5 + sin(iTime*1.2*timeScale)*.3;

    /*
    mat2 shear = mat2(1., shearFactor * uv.y, 0., 1.);

    fragCoord *= shear;
    */

    // transform into rotated space
    vec2 fragTrafo;

    for(int i = 0; i < 3; ++i)
    {
        fragTrafo = rotation * fragCoord;
    	lines.b += drawLine(fragTrafo, verticalWaveHeight*.2, verticalWaveWidth*.2, verticalWidth*.4).r;
    	lines.b += drawLine(fragTrafo + vec2(0., verticalWaveHeight*.5), verticalWaveHeight*.2, verticalWaveWidth*.2, verticalWidth*.4).r;
    	rotation *= rot;
    }

    float waveHeight = verticalWaveHeight ;//* (1. +  sin(iTime)*.25);
    float waveWidth = verticalWaveWidth * (3. +  sin(iTime));

    // Easy curves
    for(int i = 0; i < 3; ++i)
    {
        fragTrafo = rotation * (fragCoord);
    	lines += drawLine(fragTrafo, waveHeight, waveWidth, verticalWidth);
    	lines += drawLine(fragTrafo + vec2(0., waveHeight*.5), waveHeight, waveWidth, verticalWidth);
    	rotation *= rot;
    }

    // No overshooting, clean colors
    lines = clamp(lines, 0.0, 1.0);

    vec3 baseColor = blue;

    //Optional: Do HSV lerp
    vec3 gradientColorUpper = mix(violet, backgroundRed.rgb, (sin(iTime*5.*timeScale)+1.)*.5);
    vec3 gradientColor = mix(baseColor, gradientColorUpper, (uv.x+uv.y)*.5);

    vec4 background = mix(backgroundLines2, backgroundRed, lines.b);
    gl_FragColor = mix(background - lines.g*vec4(.85), vec4(gradientColor, 1.), lines.r);

}


]]>
		</program>
	</language>
</jittershader>
