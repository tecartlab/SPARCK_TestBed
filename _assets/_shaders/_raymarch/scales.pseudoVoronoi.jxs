<jittershader name="ray.template.jxs">
	<description>SPARCK - ShaderTemplate - (c) 2017 by maybites</description>

	<param name="sprk_worldMatrix" type="mat4" state="WORLD_MATRIX" />
	<param name="sprk_rotMatrix" type="mat4" default="0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0." />
	<param name="sprk_viewPos" type="vec3" default="0. 0. 0." description="test"/>
	<param name="sprk_worldRefPos" type="vec3" default="0. 0. 0." description="test"/>
	<param name="sprk_globalTime" type="float" default="0." />
	<param name="sprk_scale" type="float" default="1." />

	<param name="tex0" type="int" default="0" />
	<param name="tex1" type="int" default="1" />

    <!-- COMMENT: add here your own parameters...

    copy and modify the following lines outsite of this comment section:

	<param name="myVeryOwnFloat" type="float" default="1." description="Use_underscore_for_spaces_to_seperate_'words'"/>
	<param name="myVeryOwnVec3" type="vec3" default="0. 0. 0." description="text with spaces will only show up as 'text'"/>

    you can use parameters of the following types:

        TYPES       GUI     QUE

        -float      y       y
        -vec2       y       y
        -vec3       y       y
        -vec4       y       y
        -mat3       -       y
        -mat4       -       y

        DON'T USE int: it is reserved for textures!!

    GUI: The RayMarching Node will scan the parameters and tries to make them accessible through the userinterface
    QUE: These parameters can be sent to this shader via OSC or QueScript.

    ...Dont forget to bind it the shader: END OF COMMENT-->

	<language name="glsl" version="1.2">
		<bind param="sprk_worldMatrix" program="vp" />
		<bind param="sprk_rotMatrix" program="fp" />
		<bind param="sprk_scale" program="fp" />
		<bind param="sprk_viewPos" program="fp" />
		<bind param="sprk_worldRefPos" program="fp" />
		<bind param="sprk_globalTime" program="fp" />

		<bind param="tex0" program="fp" />
		<bind param="tex1" program="fp" />

        <!-- COMMENT: bind your own parameters here to the vertex shader (vp) and/or fragment shader (fp)

        copy and modify the following lines outsite of this comment section:

        <bind param="myVeryOwnFloat" program="fp" />
        <bind param="myVeryOwnVec3" program="fp" />

        ...until here.-->

		<program name="vp" type="vertex">
<![CDATA[

// >>>>> ================================
// >>>>> DO NOT CHANGE ANYTHING FROM HERE
// >>>>> ================================

#version 120

uniform mat4 sprk_worldMatrix;
uniform mat4 sprk_rotMatrix;

varying vec3 sprk_normal;	// surface normal
varying vec3 sprk_localPos;	// vertex local position
varying vec3 sprk_worldPos;	// vertex world position

varying vec2 sprk_texcoord0;
varying vec2 sprk_texcoord1;
varying vec2 sprk_texdim0;
varying vec2 sprk_texdim1;

void main(void)
{
	// perform standard transform on vertex (general approach)
	gl_Position = ftransform();

	gl_TexCoord[0]  = gl_TextureMatrix[0] * gl_MultiTexCoord0;

	sprk_normal = normalize(mat3(sprk_worldMatrix) * gl_Normal);
	sprk_localPos = vec3(sprk_rotMatrix * gl_Vertex);
	sprk_worldPos = vec3(sprk_worldMatrix * gl_Vertex);

	// transform texcoords
    sprk_texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
    sprk_texcoord1 = vec2(gl_TextureMatrix[1] * gl_MultiTexCoord1);
    // extract the x and y scalars from the texture matrix to determine dimensions
    sprk_texdim0 = vec2 (abs(gl_TextureMatrix[0][0][0]),abs(gl_TextureMatrix[0][1][1]));
    sprk_texdim1 = vec2 (abs(gl_TextureMatrix[1][0][0]),abs(gl_TextureMatrix[1][1][1]));
}

]]>
		</program>
		<program name="fp" type="fragment">
<![CDATA[

uniform vec3 sprk_viewPos; 			// point of view position
uniform vec3 sprk_worldRefPos;      // reference position of this virtual world
uniform mat4 sprk_rotMatrix; 		// rotation matrix
uniform float sprk_scale;			// viewline scale
uniform float sprk_globalTime; 		// time

varying vec3 sprk_normal;			// surface normal
varying vec3 sprk_worldPos;			// vertex world position
varying vec3 sprk_localPos;			// vertex local position

// samplers
uniform sampler2DRect tex0;			// texture reference for texture 0
uniform sampler2DRect tex1;			// texture reference for texture 1

// texcoords
varying vec2 sprk_texcoord0;		// texture coordinate for texture 0
varying vec2 sprk_texdim0;			// texture dimension for texture 0
varying vec2 sprk_texcoord1;		// texture coordinate for texture 1
varying vec2 sprk_texdim1;			// texture dimension for texture 0

// ================================= <<<<<<
// ...................... UNTIL HERE <<<<<<
// ================================= <<<<<<

// From here onwards will be your custom code...

// *************************************************************************
//
// Created by: KdotJPG
//	https://www.shadertoy.com/view/Wtd3zn
//
// *************************************************************************

// Add here your own parameters

uniform float myVeryOwnFloat;
uniform vec3 myVeryOwnVec3;

// If your old shader code came from shadertoy.com and used mouse interaction,
// these values will usually lead to good results
// since we dont need them anymore they can be static.

vec2 iMouse = vec2(0.5, 0.5);
vec2 iResolution = vec2(1, 1);
float iGlobalTime = sprk_globalTime;

// >>>>>>>>>>>>>>>>>>>>>>


/////////////////// Re-oriented 8-point BCC noise by KdotJPG ////////////////////
//////////////////// Output: vec4(dF/dx, dF/dy, dF/dz, value) ////////////////////

// Borrowed from Stefan Gustavson's noise code
vec4 permute(vec4 t) {
    return t * (t * 34.0 + 133.0);
}

// Gradient set is a normalized expanded rhombic dodecahedron
vec3 grad(float hash) {

    // Random vertex of a cube, +/- 1 each
    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;

    // Random edge of the three edges connected to that vertex
    // Also a cuboctahedral vertex
    // And corresponds to the face of its dual, the rhombic dodecahedron
    vec3 cuboct = cube;
    cuboct[int(hash / 16.0)] = 0.0;

    // In a funky way, pick one of the four points on the rhombic face
    float type = mod(floor(hash / 8.0), 2.0);
    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));

    // Expand it so that the new edges are the same length
    // as the existing ones
    vec3 grad = cuboct * 1.22474487139 + rhomb;

    // To make all gradients the same length, we only need to shorten the
    // second type of vector. We also put in the whole noise scale constant.
    // The compiler should reduce it into the existing floats. I think.
    grad *= (1.0 - 0.08404082057734576 * type) * 3.4105641006663014;

    return grad;
}

// BCC lattice split up into 2 cube lattices
vec4 bccNoiseDerivativesPart(vec3 X) {
    vec3 b = floor(X);
    vec4 i4 = vec4(X - b, 2.5);

    // Pick between each pair of oppposite corners in the cube.
    vec3 v1 = b + floor(dot(i4, vec4(.25)));
    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));
    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));
    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));

    // Gradient hashes for the four vertices in this half-lattice.
    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));
    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));
    hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0);

    // Gradient extrapolations & kernel function
    vec4 d1 = vec4(X - v1,0); vec4 d2 = vec4(X - v2, 0); vec4 d3 = vec4(X - v3,0); vec4 d4 = vec4(X - v4,0);
    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);
    vec4 aa = a * a; vec4 aaaa = aa * aa;
    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);
    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);
    vec4 extrapolations = vec4(dot(d1.xyz, g1), dot(d2.xyz, g2), dot(d3.xyz, g3), dot(d4.xyz, g4));

    // Derivatives of the noise
    vec3 derivative = vec3(-8.0 * mat4(d1.x, d1.y, d1.z, 0, d2.x, d2.y, d2.z, 0, d3.x, d3.y, d3.z, 0, d4.x, d4.y, d4.z, 0) * (aa * a * extrapolations)
        + mat4(g1.x, g1.y, g1.z, 0, g2.x, g2.y, g2.z, 0, g3.x, g3.y, g3.z, 0, g4.x, g4.y, g4.z, 0) * aaaa);

    // Return it all as a vec4
    return vec4(derivative, dot(aaaa, extrapolations));
}

// Rotates domain, but preserve shape. Hides grid better in cardinal slices.
// Good for texturing 3D objects with lots of flat parts along cardinal planes.
vec4 bccNoiseDerivatives_XYZ(vec3 X) {
    X = dot(X, vec3(2.0/3.0)) - X;

    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);

    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);
}

// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.
// Might be good for terrain, or a time varying X/Y plane. Z repeats.
vec4 bccNoiseDerivatives_PlaneFirst(vec3 X) {

    // Not a skew transform.
    mat3 orthonormalMap = mat3(
        0.788675134594813, -0.211324865405187, -0.577350269189626,
        -0.211324865405187, 0.788675134594813, -0.577350269189626,
        0.577350269189626, 0.577350269189626, 0.577350269189626);

    X = orthonormalMap * X;
    vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5);

    return vec4(result.xyz * orthonormalMap, result.w);
}

//////////////////////////////// End noise code ////////////////////////////////

// <<<<<<<<<<<<<<<<<<<<<<


// the main function needs to look like this:

void main() {
    // It should start with the following code block

    // =================  DO NOT CHANGE THIS CODE  =============================
	vec4 sprk_vl_raw = vec4(sprk_worldPos - sprk_viewPos - sprk_worldRefPos, 1);
	vec3 sprk_vl_dir = (sprk_rotMatrix * sprk_vl_raw).xyz;
	vec3 sprk_ray    = normalize(sprk_vl_dir) * sprk_scale;
    // =================  DO NOT CHANGE THIS CODE  =============================

    // usefull variables that are controlled by the RayMarching Node are:

    //  sprk_ray        (vec3) -> it is THE RAY
    //  sprk_viewPos;   (vec3) -> the world postion of your eye
    //  sprk_localPos   (vec3) -> the place where the ray hits the canvas. (local coordinate system)
    //  sprk_worldPos   (vec3) -> the place where the ray hits the canvas. (global coordinate system)
    //  sprk_rotMatrix  (mat4) -> rotates the ray around itself
    //  sprk_scale      (float)-> scales the ray
    //  sprk_globalTime (float)-> the global time in seconds

	// example code for gathering texture color:

    //vec3 sprk_texColor0   = texture2DRect(tex0, sprk_texcoord0).rgb;
    //vec3 sprk_texColor1   = texture2DRect(tex1, sprk_texcoord1).rgb;

    // >>>>>>>>>>>>>>>>>>>>>>

		vec2 fragCoord = sprk_texcoord0.xy;
		float iTime = sprk_globalTime;

		// Normalized pixel coordinates (from 0 to 1 on largest axis)
     vec2 uv = fragCoord / max(iResolution.x, iResolution.y) * 8.0;

     // Initial input point
     vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386);

     // 8 steps of gradient ascent
     vec4 noiseResult;
     for (int i = 0; i < 8; i++) {
     	noiseResult = bccNoiseDerivatives_PlaneFirst(X);
         X += noiseResult.xyz / 16.0;
     }

     //Get the final value
     float value = noiseResult.w;

     // Time varying pixel color
     vec3 col = vec3(value);

     // Output to screen
     gl_FragColor = vec4(col, 1.0);

    // <<<<<<<<<<<<<<<<<<<<<<

}


]]>
		</program>
	</language>
</jittershader>
